import { workerData, parentPort, Worker } from 'worker_threads';

/**
 *
 * Use this function to make any normal function a worker thread.
 *
 * @param func The CPU intensive function which needs to be parallelized
 * @example Creating a worker thread to find fibonacci number
 * ```ts
 * // fibonacci-worker.ts
 * import { createWorker } from 'worker-man';
 *
 * // A CPU intensive fibonacci implementation
 * export function getFibonacci(n : number): number {
 *   if (n < 2) return 1;
 *   else return getFibonacci(n - 2) + getFibonacci(n - 1);
 * }
 *
 * createWorker(getFibonacci);
 * ```
 */
export async function createWorker(func: (...args: any[]) => any) {
  const result = await func(workerData);
  parentPort?.postMessage(result);
}

/**
 *
 * This function will take the path to a worker thread along with the arguments
 * and return the result in asynchronous manner
 * @param path The path to the worker thread
 * @param args Arguments needed for the worker thread
 * @returns Result generated by the worker thread
 *
 * @example Using the fibonacci-worker thread in main.ts
 * ```ts
 * // main.js
 * import { useWorker } from 'worker-man';
 * import type { getFibonacci } from './fibonacci-worker.ts';
 *
 * const main = async () => {
 *  const fibonacci = await useWorker<typeof getFibonacci>('./fibonacci-worker.js', [2_000_000]);
 * }
 *
 * main();
 * ```
 */
export async function useWorker<T extends (...args: any[]) => any>(
  path: string | URL,
  args: Parameters<T>,
) {
  let x = new Promise<ReturnType<T>>((resolve, reject) => {
    const worker = new Worker(path, { workerData: args });
    worker.on('message', (result) => resolve(result));
    worker.on('error', reject);
    worker.on('exit', (code) => {
      if (code !== 0) reject(new Error(`Stopped the Worker Thread with the exit code: ${code}`));
    });
  });

  return x;
}
